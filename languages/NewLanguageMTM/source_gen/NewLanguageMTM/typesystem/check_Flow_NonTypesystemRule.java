package NewLanguageMTM.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;

public class check_Flow_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public check_Flow_NonTypesystemRule() {
  }
  public void applyRule(final SNode flow, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {


    if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(flow, LINKS.inputFlow$lMF4), LINKS.elementRef$_vnB), LINKS.type$NLpo))), CONCEPTS.ExternalEntity$hD) && SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(flow, LINKS.outputFlow$lN96), LINKS.elementRef$_vnB), LINKS.type$NLpo))), CONCEPTS.ExternalEntity$hD)) {
      {
        final MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(flow, "Ne mogu dva spoljna entiteta medjusobno da komuniciraju", "r:06138626-8f18-40f2-9813-a784ecc93b98(NewLanguageMTM.typesystem)", "6367742724884929761", null, errorTarget);
      }
    }
    if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(flow, LINKS.inputFlow$lMF4), LINKS.elementRef$_vnB), LINKS.type$NLpo))), CONCEPTS.DataStore$iB) && SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(flow, LINKS.outputFlow$lN96), LINKS.elementRef$_vnB), LINKS.type$NLpo))), CONCEPTS.DataStore$iB)) {
      {
        final MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(flow, "ne mogu dva skladista da komuniciraju medjusobno", "r:06138626-8f18-40f2-9813-a784ecc93b98(NewLanguageMTM.typesystem)", "6367742724885034721", null, errorTarget);
      }
    }
    if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(flow, LINKS.inputFlow$lMF4), LINKS.elementRef$_vnB), LINKS.type$NLpo))), CONCEPTS.DataStore$iB) && SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(flow, LINKS.outputFlow$lN96), LINKS.elementRef$_vnB), LINKS.type$NLpo))), CONCEPTS.ExternalEntity$hD)) {
      {
        final MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(flow, "izmedju eksternog entiteta i skladista mora postojati proces", "r:06138626-8f18-40f2-9813-a784ecc93b98(NewLanguageMTM.typesystem)", "6367742724885053730", null, errorTarget);
      }
    }
    if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(flow, LINKS.inputFlow$lMF4), LINKS.elementRef$_vnB), LINKS.type$NLpo))), CONCEPTS.ExternalEntity$hD) && SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(flow, LINKS.outputFlow$lN96), LINKS.elementRef$_vnB), LINKS.type$NLpo))), CONCEPTS.DataStore$iB)) {
      {
        final MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(flow, "izmedju skladista i spoljnog entiteta mora postojati proces", "r:06138626-8f18-40f2-9813-a784ecc93b98(NewLanguageMTM.typesystem)", "6367742724885080556", null, errorTarget);
      }
    }
    if (isEmptyString(SPropertyOperations.getString(SLinkOperations.getTarget(SLinkOperations.getTarget(flow, LINKS.inputFlow$lMF4), LINKS.elementRef$_vnB), PROPS.name$MnvL))) {
      {
        final MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(SLinkOperations.getTarget(SLinkOperations.getTarget(flow, LINKS.inputFlow$lMF4), LINKS.elementRef$_vnB), "Morate uneti vrednost ulaznog toka", "r:06138626-8f18-40f2-9813-a784ecc93b98(NewLanguageMTM.typesystem)", "6367742724885140315", null, errorTarget);
      }
    }
    if (isEmptyString(SPropertyOperations.getString(SLinkOperations.getTarget(SLinkOperations.getTarget(flow, LINKS.outputFlow$lN96), LINKS.elementRef$_vnB), PROPS.name$MnvL))) {
      {
        final MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(SLinkOperations.getTarget(SLinkOperations.getTarget(flow, LINKS.outputFlow$lN96), LINKS.elementRef$_vnB), "mora uneti vrednost izlaznog toka", "r:06138626-8f18-40f2-9813-a784ecc93b98(NewLanguageMTM.typesystem)", "6367742724885289517", null, errorTarget);
      }
    }
    if (isEmptyString(SPropertyOperations.getString(SLinkOperations.getTarget(flow, LINKS.dataFlow$lNQ9), PROPS.name$MnvL))) {
      {
        final MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(SLinkOperations.getTarget(flow, LINKS.dataFlow$lNQ9), "morate uneti vrednost toka podataka", "r:06138626-8f18-40f2-9813-a784ecc93b98(NewLanguageMTM.typesystem)", "6367742724885297297", null, errorTarget);
      }
    }
    if (isEmptyString(SPropertyOperations.getString(flow, PROPS.name$MnvL))) {
      {
        final MessageTarget errorTarget = new NodeMessageTarget();
        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(flow, "Tok mora biti imenovan", "r:06138626-8f18-40f2-9813-a784ecc93b98(NewLanguageMTM.typesystem)", "6367742724885258027", null, errorTarget);
      }
    }

  }
  public SAbstractConcept getApplicableConcept() {
    return CONCEPTS.Flow$x9;
  }
  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    return new IsApplicableStatus(argument.getConcept().isSubConceptOf(getApplicableConcept()), null);
  }
  public boolean overrides() {
    return false;
  }
  private static boolean isEmptyString(String str) {
    return str == null || str.isEmpty();
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink outputFlow$lN96 = MetaAdapterFactory.getContainmentLink(0x5dd044a51cd347bbL, 0xa3f5d83db0ac7aebL, 0x543ecec7f1d811ffL, 0x543ecec7f1d8cec8L, "outputFlow");
    /*package*/ static final SReferenceLink elementRef$_vnB = MetaAdapterFactory.getReferenceLink(0x5dd044a51cd347bbL, 0xa3f5d83db0ac7aebL, 0x3ced3674405df3cdL, 0x3ced3674405ff191L, "elementRef");
    /*package*/ static final SContainmentLink type$NLpo = MetaAdapterFactory.getContainmentLink(0x5dd044a51cd347bbL, 0xa3f5d83db0ac7aebL, 0x3ced3674405ff18eL, 0x5cb095e2345a9113L, "type");
    /*package*/ static final SContainmentLink inputFlow$lMF4 = MetaAdapterFactory.getContainmentLink(0x5dd044a51cd347bbL, 0xa3f5d83db0ac7aebL, 0x543ecec7f1d811ffL, 0x543ecec7f1d8cec6L, "inputFlow");
    /*package*/ static final SContainmentLink dataFlow$lNQ9 = MetaAdapterFactory.getContainmentLink(0x5dd044a51cd347bbL, 0xa3f5d83db0ac7aebL, 0x543ecec7f1d811ffL, 0x543ecec7f1d8cecbL, "dataFlow");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept ExternalEntity$hD = MetaAdapterFactory.getConcept(0x5dd044a51cd347bbL, 0xa3f5d83db0ac7aebL, 0x543ecec7f1d811f4L, "NewLanguageMTM.structure.ExternalEntity");
    /*package*/ static final SConcept DataStore$iB = MetaAdapterFactory.getConcept(0x5dd044a51cd347bbL, 0xa3f5d83db0ac7aebL, 0x543ecec7f1d811f6L, "NewLanguageMTM.structure.DataStore");
    /*package*/ static final SConcept Flow$x9 = MetaAdapterFactory.getConcept(0x5dd044a51cd347bbL, 0xa3f5d83db0ac7aebL, 0x543ecec7f1d811ffL, "NewLanguageMTM.structure.Flow");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
